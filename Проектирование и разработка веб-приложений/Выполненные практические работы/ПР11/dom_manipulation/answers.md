# Ответы на вопросы для самоконтроля (ПР11)

1. **`innerHTML` vs `textContent`**  
   - `innerHTML` интерпретирует строку как HTML и парсит её → риск XSS при вставке пользовательских данных.  
   - `textContent` вставляет «как текст» — безопасно и быстрее (не требует парсинга HTML).  
   → Используйте `textContent` для текста, `innerHTML` — только если *нужно* вставить разметку (и она *проверена*).

2. **Делегирование событий**  
   Обработчик вешается на *родительский* элемент и реагирует на всплытие событий от *дочерних* (даже динамически созданных). Преимущества:  
   - Не нужно вешать обработчик на каждый новый элемент (экономия памяти)  
   - Автоматическая поддержка динамических элементов  
   Пример: `ul.addEventListener('click', e => { if (e.target.matches('.delete')) … })`.

3. **Методы поиска элементов**  
   - `getElementById(id)` — быстро, по `id`, возвращает 1 элемент (или `null`).  
   - `querySelector(selector)` — по CSS-селектору, возвращает *первый* элемент (или `null`).  
   - `querySelectorAll(selector)` — возвращает *NodeList* всех совпадений (статический, не «живой»).  
   → Используйте `getElementById` для `id`, `querySelector[All]` — для сложных селекторов.

4. **Предотвращение стандартного поведения**  
   Через `event.preventDefault()` (например, чтобы не перезагружалась страница при `submit` формы).  
   Необходимо при:  
   - AJAX-отправке форм  
   - Кастомной обработке кликов по ссылкам (`<a href="#">`)  
   - Отмене drag/drop, контекстного меню и т.п.

5. **`classList.add()` vs `className`**  
   - `className = '...'` — перезаписывает *весь* атрибут `class`. Риск потери других классов.  
   - `classList.add('new')`, `remove()`, `toggle()` — безопасно манипулируют *отдельными* классами.  
   → Всегда предпочтительнее `classList`.

6. **Создание элементов**  
   Способы:  
   - `document.createElement(tag)` + `appendChild()` — безопасно, контролируемо.  
   - `innerHTML += '<div>…</div>'` — удобно, но медленно и небезопасно при частом использовании.  
   → Оптимальный: `createElement` + `appendChild`. Для массовой вставки — `DocumentFragment`.

7. **Всплытие событий и `stopPropagation()`**  
   Событие сначала возникает на целевом элементе, затем «всплывает» вверх по DOM-дереву.  
   `stopPropagation()` прерывает этот процесс — полезно, чтобы обработчик родителя *не* сработал.  
   Пример: всплывающее меню при клике внутри — не закрывать, только при клике *снаружи*.

8. **Получение данных из формы**  
   - `FormData(form)` — современный способ, поддерживает файлы, возвращает итерируемый объект.  
   - `form.elements.name.value` — напрямую, но хрупко (если изменить `name`, сломается).  
   → `FormData` предпочтительнее: удобен, безопасен, стандартизирован.

9. **События ввода: `input`, `change`, `keyup`**  
   - `input` — при *любом* изменении содержимого (вкл. вставка, автозаполнение) → **лучший выбор** для реального времени.  
   - `keyup` — только после отпускания клавиши (пропустит paste/автозаполнение).  
   - `change` — при потере фокуса *и* изменении — для «финального» значения.

10. **Оптимизация DOM-манипуляций**  
    - Минимизируйте обращения к DOM (кешируйте `getElementById` в переменные).  
    - Используйте `DocumentFragment` для массовой вставки.  
    - Избегайте частого `innerHTML +=` (перезаписывает всё дерево).  
    - Откладывайте обновления через `requestAnimationFrame` (для анимаций).  
    - Удаляйте неиспользуемые обработчики («утечки памяти»).