# Ответы на вопросы по JavaScript-алгоритмам

1. **O(n)** — линейная сложность: время растёт пропорционально размеру входа (например, поиск максимума в массиве).  
   **O(n²)** — квадратичная: вложенные циклы (например, пузырьковая сортировка). При удвоении данных время растёт в 4 раза.

2. **Бинарный поиск** работает только в отсортированном массиве: он делит диапазон пополам на каждом шаге.  
   Сложность **O(log n)**, потому что за каждый шаг отбрасывается половина данных.

3. **Пузырьковая сортировка**:  
   ✅ Проста в реализации, стабильна.  
   ❌ Очень медленна на больших данных (O(n²)), неэффективна даже по сравнению с вставками.

4. **Оптимизация isPrime**:  
   - Проверять делители только до √n,  
   - Пропускать чётные числа после 2,  
   - Для очень больших чисел — использовать вероятностные тесты (Миллера-Рабина).

5. **Рекурсивный Фибоначчи** имеет экспоненциальную сложность O(2ⁿ) из-за повторных вычислений.  
   **Итеративный** — O(n) и эффективен по памяти.

6. **Методы отладки**:  
   - `console.log()` для промежуточных значений,  
   - Тестирование edge cases (0, пустые строки, отрицательные числа),  
   - Пошаговое выполнение в DevTools.

7. **Алгоритм Евклида**:  
   Основан на том, что НОД(a, b) = НОД(b, a mod b).  
   Эффективен, потому что быстро уменьшает числа — сложность O(log min(a,b)).

8. **Edge cases для массивов**:  
   - Пустой массив,  
   - Один элемент,  
   - Все элементы одинаковые,  
   - Отрицательные/нецелые числа.

9. **Улучшение removeDuplicates**:  
   Использование `Set` (как сделано) — уже оптимально: O(n).  
   Для объектов — использовать `Map` или `JSON.stringify` с фильтрацией.

10. **Принципы чистого кода**:  
    - Читаемые имена функций,  
    - JSDoc-комментарии,  
    - Обработка крайних случаев,  
    - Разделение ответственности (каждая функция — одна задача),  
    - Отсутствие побочных эффектов.