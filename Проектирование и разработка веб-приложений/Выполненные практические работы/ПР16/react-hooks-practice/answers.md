# Ответы на вопросы для самоконтроля (ПР16)

---

### 1. В чём разница между `useState` и `useReducer`? Когда использовать каждый?

- **`useState`** — для простого состояния (число, строка, булево, простой объект). Прост в использовании, идеален для локального UI-состояния: счётчик, флаг открытия, ввод в поле.
- **`useReducer`** — для сложного, вложенного или взаимосвязанного состояния (корзина, форма с валидацией, секундомер). Позволяет вынести логику обновления в чистую функцию-редьюсер, упрощает тестирование и отладку.

**Когда использовать:**
- `useState` — когда логика обновления простая (`setX(x + 1)`, `setY(e => ({ ...e, a: b }))`).
- `useReducer` — когда:
  - состояние зависит от предыдущего состояния *и* действия;
  - нужно несколько подсостояний, обновляющихся вместе;
  - хочется централизованной логики (например, `dispatch({ type: 'ADD_ITEM', payload })`).

---

### 2. Как работает массив зависимостей в `useEffect`? Что произойдёт, если его не указать?

- Массив зависимостей (`deps`) — список значений, при изменении которых `useEffect` **перезапускается**.
  - `useEffect(fn, [])` — запускается **один раз** при монтировании (аналог `componentDidMount`).
  - `useEffect(fn, [a, b])` — запускается при изменении `a` или `b`.
  - `useEffect(fn)` — **без массива** — запускается **после каждого рендера** (включая обновления дочерних компонентов!), может вызвать **бесконечный цикл**, если внутри меняется состояние.

⚠️ **Если не указать массив** — эффект будет выполняться слишком часто → утечки памяти, дубли запросов, непредсказуемое поведение.

---

### 3. Что такое «stale closure» в хуках? Как использовать функциональные обновления, чтобы избежать этой проблемы?

**Stale closure** — ситуация, когда замыкание в эффекте или колбэке «запоминает» устаревшее значение из состояния.

**Пример:**
```js
const [count, setCount] = useState(0);
useEffect(() => {
  const id = setInterval(() => {
    setCount(count + 1); // ← всегда использует count = 0!
  }, 1000);
  return () => clearInterval(id);
}, []); // ← count не в зависимостях → stale closure